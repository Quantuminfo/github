#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Oct 12 15:15:04 2018

@author: pedrolauand
"""
import cvxpy as cvx
import numpy as np

B=cvx.Variable((3,3),PSD=True) #Matriz do Elipsoide
d=cvx.Variable(3,1) #Centro do Elipsoide
constrains=[] #vinculos
n=int(input("Numero de linhas:"))#Numero de linhas da matriz do Politopo
c1,c2,c3=input("Primeira coluna:"),input("Segunda coluna:"),input("Terceira coluna:")#Colunas da matriz do Politopo
c1,c2,c3=c1.split(),c2.split(),c3.split()
for i in range(n):
    c1[i],c2[i],c3[i]=float(c1[i]),float(c2[i]),float(c3[i])
C=np.array([c1,c2,c3])
C=np.transpose(C)

b=input("Vetor independente:")#Vetor do Politopo(Ax-b<=0)
b=b.split()
for i in range(n):
    b[i]=float(b[i])

for i in range(n):
    C_t=np.array([[C[i][0]],[C[i][1]],[C[i][2]]])
    constrains.append(cvx.norm(cvx.matmul(B,C_t)) + cvx.matmul(C[i],d)<= b[i])
     #Vinculos do Problema
objective=cvx.Minimize(-1*(cvx.log_det(B))) #Funcao Objetiva

prob=cvx.Problem(objective,constrains)
prob.solve()
d=d.value
B=B.value
#vamos comecar o segundo passo
R1,D,R2=np.linalg.svd(B, full_matrices=True)
#Iremos encontrar as conjugações unitárias a partir de R1 e R2
#primeiro para R1
w1,v1=np.linalg.eig(R1)
for j in range(len(w)-1):
    if w[j].imag == 0 :
        n_hat=v[j]
trR1=0
for m in range(len(w)-1):
    trR1=trR1 + w[m]

alpha1 = np.arccos((trR1 - 1)*0.5)
#definindo as matrizes de pauli
sig1,sig2,sig3 = np.array([0,1],[1,0]),np.array([0,-j],[j,0]),np.array([1,0],[0,-1])
